use std::fs::{self, File};
use std::io;
use std::path::{Path, PathBuf};
use std::process::Command;
use std::env;
use serde_json::{Value, from_reader};
use tempfile::Builder;
use walkdir::WalkDir;

struct Config {
    debug: bool,
}

impl Config {
    fn new() -> Self {
        // Check for environment variable DEBUG=1
        let debug = env::var("DEBUG").map(|v| v == "1").unwrap_or(false);
        Config { debug }
    }

    fn log(&self, message: &str) {
        if self.debug {
            println!("{}", message);
        }
    }

    fn log_fmt(&self, args: std::fmt::Arguments<'_>) {
        if self.debug {
            println!("{}", args);
        }
    }
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let config = Config::new();

    // Parse image tag from command line arguments (default: "my_image:latest")
    let args: Vec<String> = env::args().collect();
    let image_tag = match args.windows(2).find(|w| w[0] == "--image") {
        Some(pair) => pair[1].clone(),
        None => "my_image:latest".to_string(),
    };
    
    // Get the current working directory
    let current_dir = env::current_dir()?;
    config.log_fmt(format_args!("Current working directory: {}", current_dir.display()));
    
    // Remove existing extracted_output directory if it exists
    let output_dir = current_dir.join("extracted_output");
    if output_dir.exists() {
        config.log("Removing existing extracted_output directory...");
        fs::remove_dir_all(&output_dir)?;
    }
    
    // Define the path for the tar file
    let tar_path = current_dir.join("encoredocker.tar");
    
    // Step 0a: Run docker build command
    println!("Building Docker image {}...", image_tag);
    // Determine the location of the 'encore' executable
    let encore_path_output = Command::new("which")
        .arg("encore")
        .output()?;
    if !encore_path_output.status.success() {
        return Err(format!("Failed to locate 'encore' command: {}", String::from_utf8_lossy(&encore_path_output.stderr)).into());
    }
    let encore_path = String::from_utf8(encore_path_output.stdout)?.trim().to_string();
    let output = Command::new(&encore_path)
        .args(&["build", "docker", &image_tag])
        .output()?;
    if !output.status.success() {
        return Err(format!("Failed to build Docker image: {}", String::from_utf8_lossy(&output.stderr)).into());
    }
    config.log("Docker image built successfully.");

    // Step 0b: Run docker save command
    config.log_fmt(format_args!("Saving Docker image to {}...", tar_path.display()));
    let output = Command::new("docker")
        .args(&["save", "-o", tar_path.to_str().unwrap(), &image_tag])
        .output()?;
    
    if !output.status.success() {
        return Err(format!("Failed to save Docker image to file: {}", String::from_utf8_lossy(&output.stderr)).into());
    }
    println!("Saved Docker image to file successfully.");

    // Step 0c: Run docker remove images command
    config.log_fmt(format_args!("Removing Docker image node:slim and {}", &image_tag));
    let output = Command::new("docker")
        .args(&["image", "rm", "node:slim", &image_tag])
        .output()?;
    
    if !output.status.success() {
        return Err(format!("Failed to remove Docker images: {}", String::from_utf8_lossy(&output.stderr)).into());
    }
    println!("Docker images node:slim and {} removed successfully.", &image_tag);

    // Step 1: Create a temporary working directory inside the current directory
    let temp_dir_base = current_dir.join("docker_extract_temp");
    fs::create_dir_all(&temp_dir_base)?;
    let temp_dir = Builder::new()
        .prefix("work_")
        .tempdir_in(&temp_dir_base)?;
    
    config.log_fmt(format_args!("Created temporary directory: {}", temp_dir.path().display()));

    // Step 2: Extract the tar file to the temporary directory
    config.log_fmt(format_args!("Extracting Docker image from {}", tar_path.display()));
    let output = Command::new("tar")
        .arg("xf")
        .arg(&tar_path)
        .current_dir(temp_dir.path())
        .output()?;
    
    if !output.status.success() {
        return Err(format!("Failed to extract tar: {}", String::from_utf8_lossy(&output.stderr)).into());
    }

    // Step 3: Read and parse the manifest.json
    let manifest_path = temp_dir.path().join("manifest.json");
    let manifest_file = File::open(&manifest_path)?;
    let manifest: Vec<Value> = from_reader(manifest_file)?;
    
    // Step 4: Get the last layer source
    let layer_sources = &manifest[0]["LayerSources"];
    let mut largest_layer = None;
    let mut largest_size = 0;

    if let Value::Object(sources) = layer_sources {
        for (digest, info) in sources {
            if let Some(size) = info.get("size").and_then(|s| s.as_u64()) {
                if size > largest_size {
                    largest_size = size;
                    largest_layer = Some(digest.clone());
                }
            }
        }
    }

    let largest_layer = largest_layer.ok_or("No layer sources found")?;
    config.log_fmt(format_args!("Selected largest layer ({} bytes): {}", largest_size, largest_layer));

    // Remove the "sha256:" prefix if it exists
    let layer_filename = if largest_layer.starts_with("sha256:") {
        &largest_layer[7..]
    } else {
        &largest_layer
    };
    
    // Step 5: Extract the last layer using tar command
    let layer_path = temp_dir.path().join("blobs/sha256").join(layer_filename);
    config.log_fmt(format_args!("Extracting layer from {}", layer_path.display()));
    
    let layer_extract_dir = Builder::new()
        .prefix("layer_")
        .tempdir_in(&temp_dir_base)?;
    
    config.log("Using tar command to extract the layer...");
    let output = Command::new("tar")
        .arg("xzvf")  // Try with gzip first
        .arg(&layer_path)
        .current_dir(layer_extract_dir.path())
        .output()?;
    
    if !output.status.success() {
        config.log("Gzip extraction failed, trying regular tar extraction...");
        let output = Command::new("tar")
            .arg("xvf")
            .arg(&layer_path)
            .current_dir(layer_extract_dir.path())
            .output()?;
        
        if !output.status.success() {
            return Err(format!("Failed to extract layer: {}", String::from_utf8_lossy(&output.stderr)).into());
        }
    }
    
    // Step 6: Create output directory
    let output_dir = current_dir.join("encore_prod");
    fs::create_dir_all(&output_dir)?;
    config.log_fmt(format_args!("Created output directory: {}", output_dir.display()));
    
    // Step 7: Copy only the required components from the encore directory
    let encore_dir = layer_extract_dir.path().join("encore");
    
    if encore_dir.exists() && encore_dir.is_dir() {
        config.log_fmt(format_args!("Found encore directory: {}", encore_dir.display()));
        
        // Look for artifacts directory one level up from encore directory
        let artifacts_dir = encore_dir.parent()
            .map(|parent| parent.join("artifacts"))
            .unwrap_or_else(|| PathBuf::from(""));
            
        if artifacts_dir.exists() && artifacts_dir.is_dir() {
            let target_artifacts_dir = output_dir.join("artifacts");
            
            // Copy artifacts/0 folder specifically
            let artifacts_0_dir = artifacts_dir.join("0");
            if artifacts_0_dir.exists() && artifacts_0_dir.is_dir() {
                let target_artifacts_0_dir = target_artifacts_dir.join("0");
                copy_dir_all_with_exclusions(&artifacts_0_dir, &target_artifacts_0_dir, &["node_modules/.bin"], config.debug)?;
                config.log_fmt(format_args!("Copied artifacts/0 directory to {}", target_artifacts_0_dir.display()));
                
                // Copy build folder inside artifacts/0
                let build_dir = artifacts_0_dir.join("build");
                if build_dir.exists() && build_dir.is_dir() {
                    let target_build_dir = target_artifacts_0_dir.join("build");
                    copy_dir_all(&build_dir, &target_build_dir, config.debug)?;
                    config.log_fmt(format_args!("Copied build directory to {}", target_build_dir.display()));
                }
                
                // Copy node_modules folder inside artifacts/0 (excluding .bin)
                let node_modules_dir = artifacts_0_dir.join("node_modules");
                if node_modules_dir.exists() && node_modules_dir.is_dir() {
                    let target_node_modules_dir = target_artifacts_0_dir.join("node_modules");
                    copy_dir_all_with_exclusions(&node_modules_dir, &target_node_modules_dir, &[".bin"], config.debug)?;
                    config.log_fmt(format_args!("Copied node_modules directory to {}", target_node_modules_dir.display()));
                    
                    // Create .bin directory and symlinks
                    let bin_dir = target_node_modules_dir.join(".bin");
                    fs::create_dir_all(&bin_dir)?;
                    config.log_fmt(format_args!("Created .bin directory: {}", bin_dir.display()));
                    
                    // Create symlinks
                    let symlinks = [
                        ("esbuild", "/artifacts/0/node_modules/esbuild/bin/esbuild"),
                        ("rollup", "/artifacts/0/node_modules/rollup/dist/bin/rollup"),
                        ("vite", "/artifacts/0/node_modules/vite/bin/vite.js"),
                        ("vitest", "/artifacts/0/node_modules/vitest/vitest.mjs"),
                    ];
                    
                    for (link_name, target) in &symlinks {
                        let link_path = bin_dir.join(link_name);
                        
                        #[cfg(unix)]
                        {
                            use std::os::unix::fs::symlink;
                            if let Err(e) = symlink(target, &link_path) {
                                config.log_fmt(format_args!("Warning: Failed to create symlink {}: {}", link_path.display(), e));
                            } else {
                                config.log_fmt(format_args!("Created symlink: {} -> {}", link_path.display(), target));
                            }
                        }
                        
                        #[cfg(not(unix))]
                        {
                            config.log("Warning: Symlink creation not supported on this platform");
                            // On non-unix platforms, create a text file with the target path
                            let mut file = File::create(&link_path)?;
                            use std::io::Write;
                            writeln!(file, "Symlink target: {}", target)?;
                        }
                    }
                }
            } else {
                config.log("Warning: artifacts/0 directory not found");
            }
        } else {
            config.log("Warning: artifacts directory not found in parent directory");
        }
        
        let runtimes_dir = encore_dir.join("runtimes");
        if runtimes_dir.exists() && runtimes_dir.is_dir() {
            let target_runtimes_dir = output_dir.join("runtimes");
            copy_dir_all(&runtimes_dir, &target_runtimes_dir, config.debug)?;
            config.log_fmt(format_args!("Copied runtimes directory to {}", target_runtimes_dir.display()));
        } else {
            config.log("Warning: runtimes directory not found in encore directory");
        }
        
        // Copy specific files
        let files_to_copy = ["build-info.json", "infra.config.json", "meta"];
        
        for file_name in &files_to_copy {
            let source_file = encore_dir.join(file_name);
            if source_file.exists() {
                let target_file = output_dir.join(file_name);
                if source_file.is_dir() {
                    copy_dir_all(&source_file, &target_file, config.debug)?;
                } else {
                    if let Some(parent) = target_file.parent() {
                        fs::create_dir_all(parent)?;
                    }
                    fs::copy(&source_file, &target_file)?;
                }
                config.log_fmt(format_args!("Copied {} to {}", file_name, target_file.display()));
            } else {
                config.log_fmt(format_args!("Warning: {} not found in encore directory", file_name));
            }
        }
    } else {
        config.log("Error: encore directory not found in the extracted layer");
        
        // Search for the encore directory recursively
        config.log("Searching for encore directory...");
        let mut found = false;
        for entry in WalkDir::new(layer_extract_dir.path()).into_iter().filter_map(|e| e.ok()) {
            if entry.file_name() == "encore" && entry.path().is_dir() {
                config.log_fmt(format_args!("Found encore directory at: {}", entry.path().display()));
                found = true;
                
                // Try to copy the components from this location
                let found_encore_dir = entry.path();
                
                // Look for artifacts directory one level up
                let artifacts_dir = found_encore_dir.parent()
                    .map(|parent| parent.join("artifacts"))
                    .unwrap_or_else(|| PathBuf::from(""));
                    
                if artifacts_dir.exists() && artifacts_dir.is_dir() {
                    let target_artifacts_dir = output_dir.join("artifacts");
                    copy_dir_all(&artifacts_dir, &target_artifacts_dir, config.debug)?;
                    config.log_fmt(format_args!("Copied artifacts directory to {}", target_artifacts_dir.display()));
                }
                
                // Copy other components...
                let runtimes_dir = found_encore_dir.join("runtimes");
                if runtimes_dir.exists() && runtimes_dir.is_dir() {
                    let target_runtimes_dir = output_dir.join("runtimes");
                    copy_dir_all(&runtimes_dir, &target_runtimes_dir, config.debug)?;
                    config.log_fmt(format_args!("Copied runtimes directory to {}", target_runtimes_dir.display()));
                }
                
                let files_to_copy = ["build-info.json", "infra.config.json", "meta"];
                for file_name in &files_to_copy {
                    let source_file = found_encore_dir.join(file_name);
                    if source_file.exists() {
                        let target_file = output_dir.join(file_name);
                        if source_file.is_dir() {
                            copy_dir_all(&source_file, &target_file, config.debug)?;
                        } else {
                            if let Some(parent) = target_file.parent() {
                                fs::create_dir_all(parent)?;
                            }
                            fs::copy(&source_file, &target_file)?;
                        }
                        config.log_fmt(format_args!("Copied {} to {}", file_name, target_file.display()));
                    }
                }
            }
        }
        
        if !found {
            config.log("Could not find any encore directory in the extracted layer");
        }
    }
    
    println!("Process completed!");
    println!("Files have been extracted to: {}", output_dir.display());
    
    // // Clean up the temporary directories
    println!("Cleaning up temporary files...");
    fs::remove_dir_all(temp_dir_base)?;

    // Clean up the tar file
    if tar_path.exists() {
        println!("Removing tar file...");
        fs::remove_file(tar_path)?;
    }
    
    Ok(())
}

// A helper function to recursively copy directories with exclusions
fn copy_dir_all_with_exclusions(src: &Path, dst: &Path, exclusions: &[&str], debug: bool) -> io::Result<()> {
    if !src.exists() {
        return Err(io::Error::new(
            io::ErrorKind::NotFound,
            format!("Source directory does not exist: {}", src.display())
        ));
    }
    
    if !src.is_dir() {
        return Err(io::Error::new(
            io::ErrorKind::InvalidInput,
            format!("Source is not a directory: {}", src.display())
        ));
    }
    
    fs::create_dir_all(dst)?;
    
    for entry in WalkDir::new(src).min_depth(1) {
        match entry {
            Ok(entry) => {
                let path = entry.path();
                let relative_path = path.strip_prefix(src).map_err(|e| {
                    io::Error::new(io::ErrorKind::Other, format!("Strip prefix error: {}", e))
                })?;
                
                // Check if this path should be excluded
                let rel_path_str = relative_path.to_string_lossy();
                let should_exclude = exclusions.iter().any(|excl| {
                    rel_path_str == *excl || rel_path_str.starts_with(&format!("{}/", excl))
                });
                
                if should_exclude {
                    if debug {
                        println!("Skipping excluded path: {}", relative_path.display());
                    }
                    continue;
                }
                
                let target_path = dst.join(relative_path);
                
                if path.is_dir() {
                    fs::create_dir_all(&target_path)?;
                } else {
                    if let Some(parent) = target_path.parent() {
                        fs::create_dir_all(parent)?;
                    }
                    
                    if let Err(e) = fs::copy(path, &target_path) {
                        if debug {
                            println!("Warning: Failed to copy {}: {}", path.display(), e);
                        }
                    }
                }
            },
            Err(e) => {
                if debug {
                    println!("Warning: Error walking directory: {}", e);
                }
            }
        }
    }
    
    Ok(())
}

// A helper function to recursively copy directories
fn copy_dir_all(src: &Path, dst: &Path, debug: bool) -> io::Result<()> {
    if !src.exists() {
        return Err(io::Error::new(
            io::ErrorKind::NotFound,
            format!("Source directory does not exist: {}", src.display())
        ));
    }
    
    if !src.is_dir() {
        return Err(io::Error::new(
            io::ErrorKind::InvalidInput,
            format!("Source is not a directory: {}", src.display())
        ));
    }
    
    fs::create_dir_all(dst)?;
    
    for entry in WalkDir::new(src).min_depth(1) {
        match entry {
            Ok(entry) => {
                let path = entry.path();
                let relative_path = path.strip_prefix(src).map_err(|e| {
                    io::Error::new(io::ErrorKind::Other, format!("Strip prefix error: {}", e))
                })?;
                let target_path = dst.join(relative_path);
                
                if path.is_dir() {
                    fs::create_dir_all(&target_path)?;
                } else {
                    if let Some(parent) = target_path.parent() {
                        fs::create_dir_all(parent)?;
                    }
                    
                    if let Err(e) = fs::copy(path, &target_path) {
                        if debug {
                            println!("Warning: Failed to copy {}: {}", path.display(), e);
                        }
                    }
                }
            },
            Err(e) => {
                if debug {
                    println!("Warning: Error walking directory: {}", e);
                }
            }
        }
    }
    
    Ok(())
}
